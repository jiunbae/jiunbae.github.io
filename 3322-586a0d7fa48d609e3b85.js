"use strict";(self.webpackChunkjiunbae_github_io=self.webpackChunkjiunbae_github_io||[]).push([[3322],{546:function(n,e,t){function i(n){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},i(n)}function o(n){var e=function(n,e){if("object"!=i(n)||!n)return n;var t=n[Symbol.toPrimitive];if(void 0!==t){var o=t.call(n,e||"default");if("object"!=i(o))return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(n)}(n,"string");return"symbol"==i(e)?e:e+""}function r(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,o(i.key),i)}}function s(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t.d(e,{A:function(){return s}})},3322:function(n,e,t){t.r(e),t.d(e,{ShaderArtEngine:function(){return l}});var i=t(546);function o(n,e,t){const i=n.createShader(e);if(!i)throw new Error("Failed to create shader — WebGL context may be lost");if(n.shaderSource(i,t),n.compileShader(i),!n.getShaderParameter(i,n.COMPILE_STATUS)){const e=n.getShaderInfoLog(i);throw n.deleteShader(i),new Error(`Shader compile error: ${e}`)}return i}const r="\nattribute vec2 aPosition;\nvarying vec2 vUv;\nvoid main() {\n  vUv = aPosition * 0.5 + 0.5;\n  gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n",s=["Plasma","Kaleidoscope","Metaballs","Fractal Flames","Voronoi Cells","Aurora","Liquid Metal","Neon Grid"],a="\nprecision highp float;\nvarying vec2 vUv;\nuniform float uTime;\nuniform vec2 uResolution;\nuniform vec2 uMouse;\n",c=[a+"\nvoid main() {\n  vec2 uv = vUv;\n  float t = uTime * 0.8;\n  float v = 0.0;\n  vec2 c = uv * 6.0 - 3.0;\n  v += sin(c.x + t);\n  v += sin((c.y + t) * 0.5);\n  v += sin((c.x + c.y + t) * 0.5);\n  c += vec2(sin(t * 0.3), cos(t * 0.5)) * 2.0;\n  v += sin(sqrt(c.x * c.x + c.y * c.y + 1.0) + t);\n  v *= 0.5;\n\n  vec3 col = vec3(\n    sin(v * 3.14159 + 0.0) * 0.5 + 0.5,\n    sin(v * 3.14159 + 2.094) * 0.5 + 0.5,\n    sin(v * 3.14159 + 4.188) * 0.5 + 0.5\n  );\n\n  // Mouse interaction: shift colors near cursor\n  float md = length(uv - uMouse) * 3.0;\n  col = mix(col.gbr, col, smoothstep(0.0, 1.0, md));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",a+"\nvoid main() {\n  vec2 uv = (vUv - 0.5) * 2.0;\n  float aspect = uResolution.x / uResolution.y;\n  uv.x *= aspect;\n\n  float t = uTime * 0.5;\n  float angle = atan(uv.y, uv.x) + t * 0.3;\n  float r = length(uv);\n\n  // Kaleidoscope fold\n  float segments = 8.0;\n  angle = mod(angle, 3.14159 * 2.0 / segments);\n  angle = abs(angle - 3.14159 / segments);\n\n  vec2 p = vec2(cos(angle), sin(angle)) * r;\n\n  // Pattern\n  float v = 0.0;\n  v += sin(p.x * 8.0 + t * 2.0) * 0.5;\n  v += cos(p.y * 6.0 - t * 1.5) * 0.5;\n  v += sin((p.x + p.y) * 10.0 + t) * 0.3;\n  v += sin(r * 12.0 - t * 3.0) * 0.4;\n\n  vec3 col;\n  col.r = sin(v * 3.0 + t) * 0.5 + 0.5;\n  col.g = sin(v * 3.0 + t + 2.094) * 0.5 + 0.5;\n  col.b = sin(v * 3.0 + t + 4.188) * 0.5 + 0.5;\n\n  // Brighten center\n  col *= 1.0 - r * 0.3;\n  // Mouse shifts pattern\n  col *= 1.0 + 0.3 * sin(r * 6.0 + uMouse.x * 6.28);\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",a+"\nvoid main() {\n  vec2 uv = vUv;\n  float aspect = uResolution.x / uResolution.y;\n  uv.x *= aspect;\n\n  float t = uTime * 0.7;\n  float sum = 0.0;\n\n  // 6 metaballs\n  for (int i = 0; i < 6; i++) {\n    float fi = float(i);\n    vec2 center = vec2(\n      0.5 * aspect + sin(t * (0.3 + fi * 0.1) + fi * 1.2) * 0.35 * aspect,\n      0.5 + cos(t * (0.4 + fi * 0.12) + fi * 0.8) * 0.35\n    );\n    float d = length(uv - center);\n    sum += 0.015 / (d * d + 0.001);\n  }\n\n  // Mouse-controlled metaball\n  vec2 mousePos = vec2(uMouse.x * aspect, uMouse.y);\n  float md = length(uv - mousePos);\n  sum += 0.02 / (md * md + 0.001);\n\n  // Color based on field strength\n  float edge = smoothstep(8.0, 12.0, sum);\n  float glow = smoothstep(3.0, 8.0, sum);\n\n  vec3 neon1 = vec3(0.0, 1.0, 0.8);\n  vec3 neon2 = vec3(1.0, 0.0, 0.6);\n  vec3 neon3 = vec3(0.2, 0.4, 1.0);\n\n  vec3 col = mix(neon3, neon1, sin(sum * 0.3 + t) * 0.5 + 0.5);\n  col = mix(col, neon2, sin(sum * 0.2 + t * 0.5 + 1.0) * 0.5 + 0.5);\n\n  col *= glow;\n  col += vec3(1.0) * edge * 0.3;\n\n  // Subtle dark background\n  col = mix(vec3(0.02, 0.01, 0.05), col, smoothstep(2.0, 5.0, sum));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",a+"\nvec2 variation1(vec2 p, float t) {\n  return vec2(sin(p.x + t), sin(p.y + t));\n}\nvec2 variation2(vec2 p) {\n  float r2 = dot(p, p);\n  return p / (r2 + 0.001);\n}\nvec2 variation3(vec2 p, float t) {\n  float r = length(p);\n  float theta = atan(p.y, p.x);\n  return r * vec2(sin(theta + r + t), cos(theta - r + t));\n}\n\nvoid main() {\n  vec2 uv = (vUv - 0.5) * 4.0;\n  float t = uTime * 0.3;\n\n  vec3 accum = vec3(0.0);\n  vec2 p = uv + (uMouse - 0.5) * 2.0;\n\n  for (int i = 0; i < 20; i++) {\n    float fi = float(i);\n    float w = fract(fi * 0.618 + t * 0.1);\n\n    if (w < 0.33) {\n      p = variation1(p * 0.7, t + fi * 0.1);\n    } else if (w < 0.66) {\n      p = variation2(p * 0.8);\n    } else {\n      p = variation3(p * 0.6, t + fi * 0.05);\n    }\n\n    // Accumulate color\n    float intensity = exp(-length(p) * 0.5) * 0.15;\n    vec3 c = vec3(\n      sin(fi * 0.3 + t) * 0.5 + 0.5,\n      sin(fi * 0.3 + t + 2.0) * 0.5 + 0.5,\n      sin(fi * 0.3 + t + 4.0) * 0.5 + 0.5\n    );\n    accum += c * intensity;\n  }\n\n  // Tone mapping\n  accum = 1.0 - exp(-accum * 3.0);\n\n  // Vignette\n  float vig = 1.0 - dot(vUv - 0.5, vUv - 0.5) * 1.5;\n  accum *= vig;\n\n  gl_FragColor = vec4(accum, 1.0);\n}\n",a+"\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return fract(sin(p) * 43758.5453);\n}\n\nvoid main() {\n  vec2 uv = vUv;\n  float aspect = uResolution.x / uResolution.y;\n  uv.x *= aspect;\n  float t = uTime * 0.5;\n\n  float scale = 6.0;\n  vec2 st = uv * scale;\n  vec2 i_st = floor(st);\n  vec2 f_st = fract(st);\n\n  float minDist = 10.0;\n  float secondDist = 10.0;\n  vec2 minPoint = vec2(0.0);\n\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 neighbor = vec2(float(x), float(y));\n      vec2 point = hash2(i_st + neighbor);\n      // Animate points\n      point = 0.5 + 0.5 * sin(t + 6.2831 * point);\n      vec2 diff = neighbor + point - f_st;\n      float d = length(diff);\n      if (d < minDist) {\n        secondDist = minDist;\n        minDist = d;\n        minPoint = point;\n      } else if (d < secondDist) {\n        secondDist = d;\n      }\n    }\n  }\n\n  float edge = secondDist - minDist;\n\n  // Coloring\n  vec3 cellColor = vec3(\n    sin(minPoint.x * 6.28 + t) * 0.5 + 0.5,\n    sin(minPoint.y * 6.28 + t + 2.0) * 0.5 + 0.5,\n    sin((minPoint.x + minPoint.y) * 6.28 + t + 4.0) * 0.5 + 0.5\n  );\n\n  // Edge glow\n  float edgeLine = 1.0 - smoothstep(0.0, 0.08, edge);\n  vec3 edgeColor = vec3(0.9, 0.95, 1.0);\n\n  // Distance gradient inside cell\n  cellColor *= 0.3 + 0.7 * (1.0 - minDist);\n\n  vec3 col = mix(cellColor, edgeColor, edgeLine);\n\n  // Mouse proximity brightening\n  float mouseDist = length(vUv - uMouse);\n  col += 0.15 * exp(-mouseDist * 4.0);\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",a+"\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f);\n  float a = sin(dot(i, vec2(127.1, 311.7))) * 43758.5453;\n  float b = sin(dot(i + vec2(1.0, 0.0), vec2(127.1, 311.7))) * 43758.5453;\n  float c = sin(dot(i + vec2(0.0, 1.0), vec2(127.1, 311.7))) * 43758.5453;\n  float d = sin(dot(i + vec2(1.0, 1.0), vec2(127.1, 311.7))) * 43758.5453;\n  a = fract(a); b = fract(b); c = fract(c); d = fract(d);\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100.0);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n  for (int i = 0; i < 6; i++) {\n    v += a * noise(p);\n    p = rot * p * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\nvoid main() {\n  vec2 uv = vUv;\n  float t = uTime * 0.2;\n\n  // Sky gradient (dark to deep blue)\n  vec3 skyBottom = vec3(0.01, 0.01, 0.03);\n  vec3 skyTop = vec3(0.02, 0.05, 0.15);\n  vec3 sky = mix(skyBottom, skyTop, uv.y);\n\n  // Aurora layers\n  vec3 aurora = vec3(0.0);\n\n  for (int i = 0; i < 4; i++) {\n    float fi = float(i);\n    float yOffset = 0.4 + fi * 0.1;\n    float scale = 3.0 + fi * 0.5;\n\n    vec2 p = vec2(uv.x * scale + t * (0.5 + fi * 0.2), uv.y * 2.0);\n    p.x += uMouse.x * 0.5;\n    float n = fbm(p + fi * 1.3);\n    float n2 = fbm(p * 1.5 + fi * 2.7 + t * 0.3);\n\n    // Vertical curtain shape\n    float curtain = exp(-pow((uv.y - yOffset - n * 0.15) * 4.0, 2.0));\n    curtain *= smoothstep(0.2, 0.5, uv.y) * smoothstep(0.95, 0.7, uv.y);\n\n    float intensity = curtain * n2 * (0.8 + fi * 0.1);\n\n    vec3 green = vec3(0.1, 0.9, 0.3);\n    vec3 teal = vec3(0.0, 0.6, 0.8);\n    vec3 purple = vec3(0.5, 0.1, 0.8);\n    vec3 pink = vec3(0.8, 0.2, 0.5);\n\n    vec3 layerCol;\n    if (i == 0) layerCol = mix(green, teal, n);\n    else if (i == 1) layerCol = mix(teal, purple, n);\n    else if (i == 2) layerCol = mix(purple, pink, n);\n    else layerCol = mix(green, purple, n);\n\n    aurora += layerCol * intensity;\n  }\n\n  // Stars\n  vec2 starUv = uv * vec2(uResolution.x / uResolution.y, 1.0) * 40.0;\n  float star = noise(floor(starUv));\n  star = step(0.98, star) * star;\n  float twinkle = sin(star * 400.0 + t * 3.0) * 0.5 + 0.5;\n  vec3 stars = vec3(star * twinkle * 0.8);\n\n  vec3 col = sky + aurora * 1.5 + stars * (1.0 - length(aurora) * 0.5);\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",a+"\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n  float v = 0.0;\n  float a = 0.5;\n  for (int i = 0; i < 5; i++) {\n    v += a * noise(p);\n    p *= 2.0;\n    a *= 0.5;\n  }\n  return v;\n}\n\nvoid main() {\n  vec2 uv = vUv;\n  float aspect = uResolution.x / uResolution.y;\n  vec2 p = (uv - 0.5) * vec2(aspect, 1.0);\n  float t = uTime * 0.4;\n\n  // Distorted reflection coordinates\n  vec2 distort = vec2(\n    fbm(p * 3.0 + vec2(t, 0.0)),\n    fbm(p * 3.0 + vec2(0.0, t))\n  );\n  vec2 distort2 = vec2(\n    fbm(p * 3.0 + distort * 2.0 + vec2(t * 0.7, t * 0.3)),\n    fbm(p * 3.0 + distort * 2.0 + vec2(t * 0.3, t * 0.7))\n  );\n\n  // Chrome-like reflections\n  float n = fbm(p * 2.0 + distort2 * 3.0);\n\n  // Surface normal approximation\n  float eps = 0.01;\n  float nx = fbm(p * 2.0 + distort2 * 3.0 + vec2(eps, 0.0)) - n;\n  float ny = fbm(p * 2.0 + distort2 * 3.0 + vec2(0.0, eps)) - n;\n  vec3 normal = normalize(vec3(nx, ny, eps * 2.0));\n\n  // Fake environment reflection\n  vec3 viewDir = normalize(vec3(p - (uMouse - 0.5) * 0.5, 1.0));\n  vec3 reflected = reflect(viewDir, normal);\n\n  // Gradient environment\n  float envAngle = atan(reflected.y, reflected.x) * 0.318;\n  float envHeight = reflected.z * 0.5 + 0.5;\n\n  vec3 envColor = vec3(0.0);\n  envColor += vec3(0.8, 0.85, 0.9) * smoothstep(0.3, 0.7, envHeight);\n  envColor += vec3(0.2, 0.3, 0.5) * (1.0 - envHeight);\n  envColor += vec3(0.15) * sin(envAngle * 12.0 + t) * 0.5;\n\n  // Fresnel\n  float fresnel = pow(1.0 - abs(dot(vec3(0.0, 0.0, 1.0), normal)), 3.0);\n  vec3 col = mix(envColor * 0.4, envColor, fresnel + 0.5);\n\n  // Chrome specular highlights\n  float spec = pow(max(reflected.z, 0.0), 20.0);\n  col += vec3(1.0, 0.95, 0.9) * spec * 0.8;\n\n  // Warm/cool color variation\n  col *= 0.8 + 0.4 * vec3(\n    sin(n * 6.0 + t) * 0.5 + 0.5,\n    sin(n * 6.0 + t + 1.0) * 0.3 + 0.7,\n    sin(n * 6.0 + t + 2.0) * 0.5 + 0.5\n  );\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",a+"\nvoid main() {\n  vec2 uv = vUv;\n  float t = uTime;\n\n  // Sky gradient\n  vec3 col = mix(\n    vec3(0.0, 0.0, 0.02),\n    vec3(0.05, 0.0, 0.15),\n    uv.y\n  );\n\n  // Horizon line\n  float horizon = 0.35;\n\n  // Sun\n  float sunY = horizon + 0.18;\n  vec2 sunCenter = vec2(0.5, sunY);\n  float sunDist = length((uv - sunCenter) * vec2(uResolution.x / uResolution.y, 1.0));\n  vec3 sunColor = mix(vec3(1.0, 0.3, 0.6), vec3(1.0, 0.8, 0.2), smoothstep(0.0, 0.12, sunDist));\n\n  // Sun body with scanlines\n  float sunMask = smoothstep(0.12, 0.115, sunDist);\n  float scanline = step(0.5, fract(uv.y * 60.0));\n  // Clip bottom half of sun with scanline gap\n  float sunClip = smoothstep(horizon + 0.01, horizon + 0.16, uv.y);\n  sunMask *= sunClip;\n  sunMask *= mix(1.0, scanline, smoothstep(sunY - 0.05, sunY - 0.12, uv.y));\n  col = mix(col, sunColor, sunMask);\n\n  // Sun glow\n  float glow = exp(-sunDist * 6.0) * 0.6;\n  col += vec3(1.0, 0.2, 0.5) * glow;\n\n  // Grid (below horizon)\n  if (uv.y < horizon) {\n    // Perspective transform\n    float perspective = (horizon - uv.y) / horizon;\n    float z = 1.0 / (perspective + 0.01);\n    float x = (uv.x - 0.5) * z * 2.0;\n\n    // Grid lines with scrolling\n    float speed = t * 2.0;\n    float gridZ = fract(z * 0.3 - speed * 0.1);\n    float gridX = fract(x * 0.5);\n\n    float lineZ = smoothstep(0.02, 0.0, abs(gridZ - 0.5) - 0.48);\n    float lineX = smoothstep(0.02, 0.0, abs(gridX - 0.5) - 0.48);\n\n    float grid = max(lineZ, lineX);\n\n    // Fade with distance\n    float fade = exp(-perspective * 0.3);\n    grid *= fade;\n\n    // Grid color (neon cyan/pink)\n    vec3 gridColor = mix(\n      vec3(0.0, 0.8, 1.0),\n      vec3(1.0, 0.0, 0.8),\n      sin(z * 0.1 + t * 0.5) * 0.5 + 0.5\n    );\n\n    // Mouse moves grid color\n    gridColor = mix(gridColor, vec3(0.5, 0.0, 1.0), uMouse.x * 0.3);\n\n    col += gridColor * grid * 0.8;\n\n    // Fog at horizon\n    col = mix(col, vec3(0.1, 0.0, 0.2), smoothstep(0.1, 0.0, perspective));\n  }\n\n  // Horizontal glow line at horizon\n  float horizGlow = exp(-abs(uv.y - horizon) * 40.0) * 0.5;\n  col += vec3(1.0, 0.3, 0.7) * horizGlow;\n\n  // Vignette\n  float vig = 1.0 - dot((uv - 0.5) * 1.2, (uv - 0.5) * 1.2);\n  col *= vig;\n\n  gl_FragColor = vec4(col, 1.0);\n}\n"];let l=function(){function n(n){this.programs=[],this._currentIndex=0,this.prevProgram=null,this.fadeAlpha=1,this.fading=!1,this.uniformCache=new Map,this.mouse={x:.5,y:.5},this.time=0,this.animationId=0,this.lastTime=0,this.disposed=!1,this.resizeObserver=null,this.fboA=null,this.fboB=null,this.blendProgram=null,this.blendUniforms=null,this.onMouseMove=n=>{const e=this.canvas.getBoundingClientRect();this.mouse.x=(n.clientX-e.left)/e.width,this.mouse.y=1-(n.clientY-e.top)/e.height},this.onTouchMove=n=>{if(n.touches.length>0){const e=n.touches[0],t=this.canvas.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/t.width,this.mouse.y=1-(e.clientY-t.top)/t.height}},this.onResize=()=>{this.resizeCanvas(),this.resizeFBOs()},this.handleContextLost=n=>{n.preventDefault(),cancelAnimationFrame(this.animationId),function(n){const e=document.createElement("div");e.style.cssText="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);color:#fff;font:14px/1.5 sans-serif;cursor:pointer;z-index:100",e.textContent="WebGL context lost — click to reload",e.addEventListener("click",()=>location.reload()),n.style.position="relative",n.appendChild(e)}(this.container)},this.handleContextRestored=()=>{location.reload()},this.animate=()=>{if(this.disposed)return;this.animationId=requestAnimationFrame(this.animate);const n=performance.now(),e=Math.min(.001*(n-this.lastTime),.05);this.lastTime=n,this.time+=e;const t=this.programs[this._currentIndex];this.fading&&this.prevProgram&&this.fboA&&this.fboB?(this.renderProgram(this.prevProgram,this.fboA.framebuffer),this.renderProgram(t,this.fboB.framebuffer),this.fadeAlpha=Math.min(this.fadeAlpha+2.5*e,1),this.fadeAlpha>=1&&(this.fading=!1,this.prevProgram=null),this.renderBlend(this.fboA.texture,this.fboB.texture,this.fadeAlpha)):this.renderProgram(t,null)},this.container=n,this.canvas=document.createElement("canvas"),this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.display="block",n.appendChild(this.canvas);const e=this.canvas.getContext("webgl",{alpha:!1,depth:!1,stencil:!1,antialias:!1,preserveDrawingBuffer:!1});if(!e)throw new Error("WebGL not supported");this.gl=e,this.canvas.addEventListener("webglcontextlost",this.handleContextLost),this.canvas.addEventListener("webglcontextrestored",this.handleContextRestored),this.vertShader=o(e,e.VERTEX_SHADER,r),this.quadBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),e.STATIC_DRAW);for(const t of c){const n=this.buildProgram(t);this.programs.push(n)}this.initBlendProgram(),this.resizeCanvas(),this.initFBOs(),this.initListeners(),this.lastTime=performance.now(),this.animate()}var e=n.prototype;return e.setShader=function(n){n<0||n>=this.programs.length||(n!==this._currentIndex||this.fading)&&(this.prevProgram=this.programs[this._currentIndex],this._currentIndex=n,this.fadeAlpha=0,this.fading=!0)},e.dispose=function(){var n;this.disposed=!0,cancelAnimationFrame(this.animationId),this.removeListeners(),this.canvas.removeEventListener("webglcontextlost",this.handleContextLost),this.canvas.removeEventListener("webglcontextrestored",this.handleContextRestored),this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=null),null===(n=this.gl.getExtension("WEBGL_lose_context"))||void 0===n||n.loseContext(),this.canvas.parentElement&&this.canvas.parentElement.removeChild(this.canvas)},e.buildProgram=function(n){const e=this.gl,t=o(e,e.FRAGMENT_SHADER,n),i=e.createProgram();if(!i)throw new Error("Failed to create program — WebGL context may be lost");if(e.attachShader(i,this.vertShader),e.attachShader(i,t),e.bindAttribLocation(i,0,"aPosition"),e.linkProgram(i),!e.getProgramParameter(i,e.LINK_STATUS))throw new Error(`Program link error: ${e.getProgramInfoLog(i)}`);return this.uniformCache.set(i,{uTime:e.getUniformLocation(i,"uTime"),uResolution:e.getUniformLocation(i,"uResolution"),uMouse:e.getUniformLocation(i,"uMouse")}),i},e.initBlendProgram=function(){const n=this.gl;this.blendProgram=function(n,e,t){const i=n.createProgram();if(!i)throw new Error("Failed to create program — WebGL context may be lost");if(n.attachShader(i,o(n,n.VERTEX_SHADER,e)),n.attachShader(i,o(n,n.FRAGMENT_SHADER,t)),n.linkProgram(i),!n.getProgramParameter(i,n.LINK_STATUS))throw new Error(`Program link error: ${n.getProgramInfoLog(i)}`);return i}(n,r,"\n      precision highp float;\n      varying vec2 vUv;\n      uniform sampler2D uTexA;\n      uniform sampler2D uTexB;\n      uniform float uMix;\n      void main() {\n        vec4 a = texture2D(uTexA, vUv);\n        vec4 b = texture2D(uTexB, vUv);\n        gl_FragColor = mix(a, b, uMix);\n      }\n    "),n.bindAttribLocation(this.blendProgram,0,"aPosition"),n.linkProgram(this.blendProgram),this.blendUniforms={uTexA:n.getUniformLocation(this.blendProgram,"uTexA"),uTexB:n.getUniformLocation(this.blendProgram,"uTexB"),uMix:n.getUniformLocation(this.blendProgram,"uMix")}},e.createFBO=function(){const n=this.gl,e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,this.canvas.width,this.canvas.height,0,n.RGBA,n.UNSIGNED_BYTE,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);const t=n.createFramebuffer();return n.bindFramebuffer(n.FRAMEBUFFER,t),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0),n.bindFramebuffer(n.FRAMEBUFFER,null),{framebuffer:t,texture:e}},e.initFBOs=function(){this.fboA=this.createFBO(),this.fboB=this.createFBO()},e.resizeCanvas=function(){const n=Math.min(window.devicePixelRatio,2),e=this.container.clientWidth,t=this.container.clientHeight;this.canvas.width=Math.floor(e*n),this.canvas.height=Math.floor(t*n)},e.resizeFBOs=function(){const n=this.gl,e=this.canvas.width,t=this.canvas.height;this.fboA&&(n.bindTexture(n.TEXTURE_2D,this.fboA.texture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e,t,0,n.RGBA,n.UNSIGNED_BYTE,null)),this.fboB&&(n.bindTexture(n.TEXTURE_2D,this.fboB.texture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e,t,0,n.RGBA,n.UNSIGNED_BYTE,null))},e.renderProgram=function(n,e){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,e),t.viewport(0,0,this.canvas.width,this.canvas.height),t.useProgram(n);const i=this.uniformCache.get(n);i&&(i.uTime&&t.uniform1f(i.uTime,this.time),i.uResolution&&t.uniform2f(i.uResolution,this.canvas.width,this.canvas.height),i.uMouse&&t.uniform2f(i.uMouse,this.mouse.x,this.mouse.y)),t.bindBuffer(t.ARRAY_BUFFER,this.quadBuffer),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLE_FAN,0,4)},e.renderBlend=function(n,e,t){const i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,null),i.viewport(0,0,this.canvas.width,this.canvas.height),i.useProgram(this.blendProgram),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,n),i.uniform1i(this.blendUniforms.uTexA,0),i.activeTexture(i.TEXTURE1),i.bindTexture(i.TEXTURE_2D,e),i.uniform1i(this.blendUniforms.uTexB,1),i.uniform1f(this.blendUniforms.uMix,t),i.bindBuffer(i.ARRAY_BUFFER,this.quadBuffer),i.enableVertexAttribArray(0),i.vertexAttribPointer(0,2,i.FLOAT,!1,0,0),i.drawArrays(i.TRIANGLE_FAN,0,4)},e.initListeners=function(){this.canvas.addEventListener("mousemove",this.onMouseMove),this.canvas.addEventListener("touchmove",this.onTouchMove,{passive:!0}),this.resizeObserver=new ResizeObserver(()=>{this.disposed||this.onResize()}),this.resizeObserver.observe(this.container)},e.removeListeners=function(){this.canvas.removeEventListener("mousemove",this.onMouseMove),this.canvas.removeEventListener("touchmove",this.onTouchMove)},(0,i.A)(n,[{key:"shaderCount",get:function(){return this.programs.length}},{key:"shaderNames",get:function(){return[].concat(s)}},{key:"currentIndex",get:function(){return this._currentIndex}}])}()}}]);
//# sourceMappingURL=3322-586a0d7fa48d609e3b85.js.map