{"version":3,"file":"7943-9e42a8001400c4ea07f9.js","mappings":"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","sources":["webpack://jiunbae.github.io/./node_modules/.pnpm/@babel+runtime@7.28.6/node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@babel+runtime@7.28.6/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@babel+runtime@7.28.6/node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@babel+runtime@7.28.6/node_modules/@babel/runtime/helpers/esm/createClass.js","webpack://jiunbae.github.io/./src/views/Raymarching/engine.ts"],"sourcesContent":["function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nexport { _createClass as default };","/**\n * Pure WebGL raymarching engine with 4 world presets.\n * Full-screen fragment shader with sphere tracing, Phong lighting, and AO.\n */\n\n// ── Shader helpers ──────────────────────────────────────────────────\n\nfunction compileShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader {\n  const shader = gl.createShader(type)\n  if (!shader) throw new Error('Failed to create shader — WebGL context may be lost')\n  gl.shaderSource(shader, source)\n  gl.compileShader(shader)\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const info = gl.getShaderInfoLog(shader)\n    gl.deleteShader(shader)\n    throw new Error(`Shader compile error: ${info}`)\n  }\n  return shader\n}\n\nfunction createProgram(gl: WebGLRenderingContext, vertSrc: string, fragSrc: string): WebGLProgram {\n  const program = gl.createProgram()\n  if (!program) throw new Error('Failed to create program — WebGL context may be lost')\n  gl.attachShader(program, compileShader(gl, gl.VERTEX_SHADER, vertSrc))\n  gl.attachShader(program, compileShader(gl, gl.FRAGMENT_SHADER, fragSrc))\n  gl.linkProgram(program)\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    throw new Error(`Program link error: ${gl.getProgramInfoLog(program)}`)\n  }\n  return program\n}\n\n// ── Shader sources ──────────────────────────────────────────────────\n\nconst VERT_SRC = `\n  attribute vec2 aPosition;\n  void main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n  }\n`\n\nconst FRAG_SRC = `\n  precision highp float;\n\n  uniform float uTime;\n  uniform vec2 uResolution;\n  uniform vec2 uMouse;\n  uniform int uScene;\n\n  // ── SDF primitives ─────────────────────────────────────────────\n\n  float sdSphere(vec3 p, float r) {\n    return length(p) - r;\n  }\n\n  float sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n  }\n\n  float sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n  }\n\n  float sdPlane(vec3 p, float h) {\n    return p.y - h;\n  }\n\n  float sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n  }\n\n  // ── SDF operations ─────────────────────────────────────────────\n\n  float opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n  }\n\n  float opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n  }\n\n  vec3 opRepeat(vec3 p, vec3 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n  }\n\n  mat2 rot2D(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n  }\n\n  // ── Scene 0: Alien Planet ──────────────────────────────────────\n\n  float sceneAlienPlanet(vec3 p) {\n    // Ground plane with organic displacement\n    float ground = p.y + 1.0;\n    ground += sin(p.x * 0.8) * cos(p.z * 0.8) * 0.3;\n    ground += sin(p.x * 2.0 + uTime * 0.3) * cos(p.z * 1.5) * 0.1;\n\n    // Twisted columns\n    float columns = 1e10;\n    for (int i = 0; i < 5; i++) {\n      float fi = float(i);\n      float angle = fi * 1.2566; // 2PI/5\n      float radius = 3.0;\n      vec3 colPos = p - vec3(cos(angle) * radius, 0.0, sin(angle) * radius);\n\n      // Twist\n      float twist = sin(colPos.y * 0.5 + uTime * 0.2 + fi) * 0.5;\n      colPos.xz *= rot2D(twist);\n\n      // Organic column shape: cylinder with distortion\n      float col = sdCappedCylinder(colPos, 3.0, 0.3 + sin(colPos.y * 1.5 + fi) * 0.1);\n      col += sin(colPos.y * 3.0 + uTime * 0.5) * 0.05;\n      col += sin(p.x * 2.0 + fi) * cos(p.z * 2.0) * 0.04;\n\n      columns = min(columns, col);\n    }\n\n    // Floating organic orbs\n    float orbs = 1e10;\n    for (int i = 0; i < 3; i++) {\n      float fi = float(i);\n      float t = uTime * 0.3 + fi * 2.094;\n      vec3 orbPos = vec3(sin(t) * 2.0, 1.5 + sin(t * 0.7 + fi) * 0.5, cos(t) * 2.0);\n      float orb = sdSphere(p - orbPos, 0.25 + sin(uTime + fi) * 0.05);\n      orbs = min(orbs, orb);\n    }\n\n    float scene = min(ground, columns);\n    scene = min(scene, orbs);\n    return scene;\n  }\n\n  // ── Scene 1: Crystal Cave ──────────────────────────────────────\n\n  float sceneCrystalCave(vec3 p) {\n    // Cavern shell (inverted sphere)\n    float cavern = -(length(p) - 8.0);\n    cavern += sin(p.x * 1.5) * sin(p.y * 1.5) * sin(p.z * 1.5) * 0.4;\n\n    // Repeated crystal formations\n    vec3 rep = opRepeat(p, vec3(3.0, 4.0, 3.0));\n\n    // Rotate crystals\n    float t = uTime * 0.15;\n    rep.xy *= rot2D(t);\n    rep.yz *= rot2D(t * 0.7);\n\n    float crystals = sdBox(rep, vec3(0.15, 0.6, 0.15));\n    crystals = min(crystals, sdBox(rep, vec3(0.6, 0.15, 0.15)));\n    crystals = min(crystals, sdBox(rep, vec3(0.15, 0.15, 0.6)));\n\n    // Stalactites from ceiling\n    vec3 stalPos = p;\n    stalPos.xz = mod(stalPos.xz + 1.5, 3.0) - 1.5;\n    float stalactites = sdCappedCylinder(stalPos - vec3(0.0, 5.0, 0.0), 2.0, 0.1);\n    stalactites -= sin(stalPos.y * 4.0) * 0.03;\n\n    // Stalagmites from floor\n    float stalagmites = sdCappedCylinder(stalPos + vec3(0.0, 5.0, 0.0), 1.5, 0.12);\n    stalagmites -= sin(stalPos.y * 3.0) * 0.04;\n\n    float scene = cavern;\n    scene = min(scene, crystals);\n    scene = min(scene, stalactites);\n    scene = min(scene, stalagmites);\n    return scene;\n  }\n\n  // ── Scene 2: Fractal Landscape ─────────────────────────────────\n\n  float sceneFractalLandscape(vec3 p) {\n    // Multi-octave terrain\n    float terrain = p.y;\n\n    // Mandelbulb-inspired displacement\n    float scale = 1.0;\n    float detail = 0.0;\n    vec3 q = p * 0.3;\n    for (int i = 0; i < 5; i++) {\n      detail += abs(sin(q.x * scale) * cos(q.z * scale)) / scale;\n      scale *= 2.17;\n      q.xz *= rot2D(0.45);\n    }\n    terrain += detail * 1.5 - 2.0;\n\n    // Add some sharp ridges\n    float ridges = abs(sin(p.x * 0.5 + sin(p.z * 0.3)) * cos(p.z * 0.5)) * 1.2;\n    terrain -= ridges;\n\n    // Floating fractal-esque rocks\n    float rocks = 1e10;\n    for (int i = 0; i < 4; i++) {\n      float fi = float(i);\n      float t = uTime * 0.1;\n      vec3 rockPos = vec3(\n        sin(fi * 1.7 + t) * 5.0,\n        3.0 + sin(fi * 2.3 + t * 0.5) * 1.0,\n        cos(fi * 1.3 + t * 0.7) * 5.0\n      );\n      float rock = sdSphere(p - rockPos, 0.3 + sin(fi + uTime * 0.3) * 0.1);\n      // Fractal displacement on rocks\n      vec3 rp = (p - rockPos) * 4.0;\n      rock += (sin(rp.x) * sin(rp.y) * sin(rp.z)) * 0.05;\n      rocks = min(rocks, rock);\n    }\n\n    return min(terrain, rocks);\n  }\n\n  // ── Scene 3: Abstract Geometry ─────────────────────────────────\n\n  float sceneAbstractGeometry(vec3 p) {\n    float t = uTime * 0.3;\n\n    // Central rotating torus\n    vec3 p1 = p;\n    p1.xy *= rot2D(t);\n    float torus1 = sdTorus(p1, vec2(2.0, 0.3));\n\n    // Second torus, orthogonal\n    vec3 p2 = p;\n    p2.yz *= rot2D(t * 0.7);\n    float torus2 = sdTorus(p2, vec2(2.0, 0.3));\n\n    // Third torus\n    vec3 p3 = p;\n    p3.xz *= rot2D(t * 1.1);\n    float torus3 = sdTorus(p3, vec2(2.0, 0.3));\n\n    // Smooth union of toruses\n    float toruses = opSmoothUnion(torus1, torus2, 0.5);\n    toruses = opSmoothUnion(toruses, torus3, 0.5);\n\n    // Central sphere\n    float sphere = sdSphere(p, 1.0 + sin(t) * 0.2);\n\n    // Orbiting smaller spheres\n    float orbitals = 1e10;\n    for (int i = 0; i < 6; i++) {\n      float fi = float(i);\n      float angle = fi * 1.0472 + t; // 2PI/6\n      vec3 oPos = vec3(\n        cos(angle) * 3.0,\n        sin(fi * 0.5 + t * 0.5) * 1.0,\n        sin(angle) * 3.0\n      );\n      float orb = sdSphere(p - oPos, 0.3);\n      orbitals = min(orbitals, orb);\n    }\n\n    // Smooth union everything\n    float scene = opSmoothUnion(toruses, sphere, 0.3);\n    scene = opSmoothUnion(scene, orbitals, 0.4);\n\n    return scene;\n  }\n\n  // ── Main distance function ─────────────────────────────────────\n\n  float map(vec3 p) {\n    if (uScene == 0) return sceneAlienPlanet(p);\n    if (uScene == 1) return sceneCrystalCave(p);\n    if (uScene == 2) return sceneFractalLandscape(p);\n    return sceneAbstractGeometry(p);\n  }\n\n  // ── Normal calculation (central differences) ──────────────────\n\n  vec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n      map(p + e.xyy) - map(p - e.xyy),\n      map(p + e.yxy) - map(p - e.yxy),\n      map(p + e.yyx) - map(p - e.yyx)\n    ));\n  }\n\n  // ── Sphere tracing ────────────────────────────────────────────\n\n  float raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n      vec3 p = ro + rd * t;\n      float d = map(p);\n      if (d < 0.001) break;\n      t += d;\n      if (t > 100.0) break;\n    }\n    return t;\n  }\n\n  // ── Ambient occlusion approximation ────────────────────────────\n\n  float calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n      float h = 0.01 + 0.12 * float(i);\n      float d = map(p + h * n);\n      occ += (h - d) * sca;\n      sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n  }\n\n  // ── Soft shadow ───────────────────────────────────────────────\n\n  float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 32; i++) {\n      float h = map(ro + rd * t);\n      res = min(res, k * h / t);\n      t += clamp(h, 0.02, 0.1);\n      if (h < 0.001 || t > maxt) break;\n    }\n    return clamp(res, 0.0, 1.0);\n  }\n\n  // ── Scene-specific coloring ────────────────────────────────────\n\n  vec3 getSceneColor(vec3 p, vec3 n, vec3 rd, float t) {\n    vec3 lightDir = normalize(vec3(0.8, 0.6, -0.5));\n    float diff = max(dot(n, lightDir), 0.0);\n    float spec = pow(max(dot(reflect(rd, n), lightDir), 0.0), 32.0);\n    float ao = calcAO(p, n);\n    float shadow = softShadow(p + n * 0.01, lightDir, 0.02, 10.0, 8.0);\n\n    vec3 col;\n\n    if (uScene == 0) {\n      // Alien Planet - warm organic tones\n      vec3 albedo = vec3(0.3, 0.5, 0.4);\n      // Height-based color: lower = dark, higher = bright teal\n      albedo = mix(vec3(0.15, 0.1, 0.08), vec3(0.2, 0.7, 0.5), clamp(p.y * 0.3 + 0.5, 0.0, 1.0));\n      // Columns: more saturated\n      if (abs(p.y) < 3.0 && length(p.xz) > 1.5 && length(p.xz) < 4.5) {\n        albedo = mix(albedo, vec3(0.6, 0.2, 0.8), 0.3);\n      }\n      vec3 ambient = vec3(0.08, 0.05, 0.12) * ao;\n      col = ambient + albedo * diff * shadow + vec3(0.6, 0.8, 0.9) * spec * 0.3;\n\n      // Sky gradient for distant fragments\n      vec3 sky = mix(vec3(0.15, 0.05, 0.2), vec3(0.4, 0.2, 0.5), clamp(rd.y * 0.5 + 0.5, 0.0, 1.0));\n      float fog = 1.0 - exp(-t * 0.04);\n      col = mix(col, sky, fog);\n\n    } else if (uScene == 1) {\n      // Crystal Cave - dark with colored light sources\n      vec3 albedo = vec3(0.3, 0.35, 0.5);\n      // Add crystalline iridescence\n      float irid = sin(dot(p, vec3(1.0, 2.0, 3.0)) * 3.0 + uTime * 0.5);\n      albedo += vec3(0.15, 0.1, 0.25) * irid;\n\n      // Point lights in the cave\n      vec3 lightAccum = vec3(0.0);\n      for (int i = 0; i < 3; i++) {\n        float fi = float(i);\n        vec3 lp = vec3(sin(fi * 2.094 + uTime * 0.2) * 3.0, sin(fi + uTime * 0.3), cos(fi * 2.094 + uTime * 0.2) * 3.0);\n        vec3 lCol = vec3(0.0);\n        if (i == 0) lCol = vec3(0.3, 0.5, 1.0);\n        if (i == 1) lCol = vec3(1.0, 0.3, 0.5);\n        if (i == 2) lCol = vec3(0.3, 1.0, 0.5);\n        float dist = length(p - lp);\n        float atten = 1.0 / (1.0 + dist * dist * 0.1);\n        float ld = max(dot(n, normalize(lp - p)), 0.0);\n        lightAccum += lCol * ld * atten;\n      }\n\n      vec3 ambient = vec3(0.02, 0.02, 0.04) * ao;\n      col = ambient + albedo * (diff * shadow * 0.3 + lightAccum) + vec3(0.5) * spec * 0.2;\n\n      // Dark cave fog\n      float fog = 1.0 - exp(-t * 0.08);\n      col = mix(col, vec3(0.01, 0.01, 0.03), fog);\n\n    } else if (uScene == 2) {\n      // Fractal Landscape - earthy terrain tones\n      vec3 albedo = vec3(0.35, 0.25, 0.15);\n      // Height-based: low=green, mid=brown, high=snow\n      float h = p.y;\n      if (h < -0.5) albedo = vec3(0.1, 0.25, 0.1); // grass\n      else if (h < 0.5) albedo = vec3(0.35, 0.25, 0.15); // dirt/rock\n      else if (h < 1.5) albedo = vec3(0.4, 0.38, 0.35); // stone\n      else albedo = vec3(0.85, 0.88, 0.95); // snow\n\n      // Normal-based grass on slopes\n      if (n.y > 0.7 && h < 0.5) {\n        albedo = mix(albedo, vec3(0.15, 0.35, 0.1), (n.y - 0.7) * 3.0);\n      }\n\n      vec3 skyCol = mix(vec3(0.6, 0.7, 0.9), vec3(0.2, 0.3, 0.6), clamp(rd.y, 0.0, 1.0));\n      vec3 ambient = vec3(0.08, 0.1, 0.15) * ao;\n      col = ambient + albedo * diff * shadow + vec3(0.8, 0.85, 1.0) * spec * 0.15;\n\n      float fog = 1.0 - exp(-t * 0.025);\n      col = mix(col, skyCol * 0.5, fog);\n\n    } else {\n      // Abstract Geometry - clean modern look\n      vec3 albedo = vec3(0.9, 0.92, 0.95);\n      // Fresnel for rim light\n      float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 3.0);\n\n      // Color based on normal direction\n      vec3 normColor = n * 0.5 + 0.5;\n      albedo = mix(albedo, normColor * 0.8 + 0.2, 0.3);\n\n      vec3 lightDir2 = normalize(vec3(-0.5, 0.8, 0.3));\n      float diff2 = max(dot(n, lightDir2), 0.0) * 0.3;\n\n      vec3 ambient = vec3(0.12, 0.1, 0.15) * ao;\n      col = ambient + albedo * (diff * shadow + diff2) + vec3(1.0) * spec * 0.5;\n      col += vec3(0.3, 0.5, 1.0) * fresnel * 0.4;\n\n      // Light fog\n      vec3 bgCol = vec3(0.04, 0.04, 0.06);\n      float fog = 1.0 - exp(-t * 0.03);\n      col = mix(col, bgCol, fog);\n    }\n\n    return col;\n  }\n\n  // ── Main ──────────────────────────────────────────────────────\n\n  void main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / uResolution.y;\n\n    // Camera: mouse X controls orbit angle, mouse Y controls height\n    float mouseX = uMouse.x * 2.0 - 1.0; // -1 to 1\n    float mouseY = uMouse.y * 2.0 - 1.0; // -1 to 1\n    float camAngle = mouseX * 3.14159;\n    float camHeight = mouseY * 3.0;\n\n    vec3 ro, lookAt;\n\n    if (uScene == 0) {\n      // Alien planet: orbit around center\n      ro = vec3(cos(camAngle) * 6.0, 2.0 + camHeight, sin(camAngle) * 6.0);\n      lookAt = vec3(0.0, 0.5, 0.0);\n    } else if (uScene == 1) {\n      // Crystal cave: orbit inside\n      ro = vec3(cos(camAngle) * 3.0, camHeight * 0.5, sin(camAngle) * 3.0);\n      lookAt = vec3(0.0, 0.0, 0.0);\n    } else if (uScene == 2) {\n      // Fractal landscape: orbit from above\n      float orbitT = uTime * 0.05 + camAngle * 0.3;\n      ro = vec3(cos(orbitT) * 8.0, 5.0 + camHeight, sin(orbitT) * 8.0);\n      lookAt = vec3(0.0, -0.5, 0.0);\n    } else {\n      // Abstract: orbit around\n      ro = vec3(cos(camAngle) * 5.5, 1.5 + camHeight, sin(camAngle) * 5.5);\n      lookAt = vec3(0.0, 0.0, 0.0);\n    }\n\n    // Camera matrix\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n\n    // Raymarch\n    float t = raymarch(ro, rd);\n\n    vec3 col;\n\n    if (t < 100.0) {\n      vec3 p = ro + rd * t;\n      vec3 n = calcNormal(p);\n      col = getSceneColor(p, n, rd, t);\n    } else {\n      // Background\n      if (uScene == 0) {\n        // Sky gradient\n        col = mix(vec3(0.15, 0.05, 0.2), vec3(0.4, 0.2, 0.5), clamp(rd.y * 0.5 + 0.5, 0.0, 1.0));\n        // Stars\n        vec3 starUV = rd * 200.0;\n        float star = step(0.98, fract(sin(dot(floor(starUV), vec3(12.9898, 78.233, 45.164))) * 43758.5453));\n        col += star * 0.4;\n      } else if (uScene == 1) {\n        col = vec3(0.01, 0.01, 0.03);\n      } else if (uScene == 2) {\n        col = mix(vec3(0.6, 0.7, 0.9), vec3(0.2, 0.3, 0.6), clamp(rd.y, 0.0, 1.0)) * 0.5;\n      } else {\n        col = vec3(0.04, 0.04, 0.06);\n      }\n    }\n\n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n\n    // Vignette\n    vec2 vUv = gl_FragCoord.xy / uResolution;\n    vec2 vig = vUv * (1.0 - vUv);\n    col *= pow(vig.x * vig.y * 16.0, 0.15);\n\n    gl_FragColor = vec4(col, 1.0);\n  }\n`\n\n// ── Scene names ─────────────────────────────────────────────────────\n\nconst SCENE_NAMES = [\n  'Alien Planet',\n  'Crystal Cave',\n  'Fractal Landscape',\n  'Abstract Geometry'\n]\n\n// ── Context loss overlay ─────────────────────────────────────────────\n\nfunction showContextLostOverlay(container: HTMLElement): HTMLDivElement {\n  const overlay = document.createElement('div')\n  overlay.style.cssText = 'position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);color:#fff;font:14px/1.5 sans-serif;cursor:pointer;z-index:100'\n  overlay.textContent = 'WebGL context lost — click to reload'\n  overlay.addEventListener('click', () => location.reload())\n  container.style.position = 'relative'\n  container.appendChild(overlay)\n  return overlay\n}\n\n// ── Engine ──────────────────────────────────────────────────────────\n\nexport class RaymarchEngine {\n  private canvas: HTMLCanvasElement\n  private gl: WebGLRenderingContext\n  private program: WebGLProgram\n  private quadBuffer: WebGLBuffer\n\n  // Uniform locations\n  private uTime: WebGLUniformLocation | null\n  private uResolution: WebGLUniformLocation | null\n  private uMouse: WebGLUniformLocation | null\n  private uScene: WebGLUniformLocation | null\n\n  private animationId = 0\n  private disposed = false\n  private startTime: number\n  private mouseX = 0.5\n  private mouseY = 0.5\n  private scene = 0\n\n  constructor(private container: HTMLDivElement) {\n    this.canvas = document.createElement('canvas')\n    this.canvas.style.display = 'block'\n    this.canvas.style.width = '100%'\n    this.canvas.style.height = '100%'\n    container.appendChild(this.canvas)\n\n    const gl = this.canvas.getContext('webgl', {\n      alpha: false,\n      depth: false,\n      stencil: false,\n      antialias: false,\n      preserveDrawingBuffer: false\n    })\n    if (!gl) throw new Error('WebGL not supported')\n    this.gl = gl\n\n    this.canvas.addEventListener('webglcontextlost', this.handleContextLost)\n    this.canvas.addEventListener('webglcontextrestored', this.handleContextRestored)\n\n    this.program = createProgram(gl, VERT_SRC, FRAG_SRC)\n    gl.useProgram(this.program)\n\n    // Uniform locations\n    this.uTime = gl.getUniformLocation(this.program, 'uTime')\n    this.uResolution = gl.getUniformLocation(this.program, 'uResolution')\n    this.uMouse = gl.getUniformLocation(this.program, 'uMouse')\n    this.uScene = gl.getUniformLocation(this.program, 'uScene')\n\n    // Full-screen quad\n    this.quadBuffer = gl.createBuffer()!\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer)\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n      -1, -1, -1, 1, 1, 1,\n      -1, -1, 1, 1, 1, -1\n    ]), gl.STATIC_DRAW)\n\n    const aPosition = gl.getAttribLocation(this.program, 'aPosition')\n    gl.enableVertexAttribArray(aPosition)\n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0)\n\n    this.startTime = performance.now()\n\n    this.resize()\n    window.addEventListener('resize', this.handleResize)\n    this.canvas.addEventListener('mousemove', this.handleMouseMove)\n    this.canvas.addEventListener('touchmove', this.handleTouchMove, { passive: false })\n\n    this.animate()\n  }\n\n  // ── Public API ────────────────────────────────────────────────\n\n  setScene(index: number) {\n    this.scene = Math.max(0, Math.min(index, SCENE_NAMES.length - 1))\n  }\n\n  get sceneCount(): number {\n    return SCENE_NAMES.length\n  }\n\n  get sceneNames(): string[] {\n    return [...SCENE_NAMES]\n  }\n\n  get currentScene(): number {\n    return this.scene\n  }\n\n  dispose() {\n    this.disposed = true\n    cancelAnimationFrame(this.animationId)\n    window.removeEventListener('resize', this.handleResize)\n    this.canvas.removeEventListener('mousemove', this.handleMouseMove)\n    this.canvas.removeEventListener('touchmove', this.handleTouchMove)\n    this.canvas.removeEventListener('webglcontextlost', this.handleContextLost)\n    this.canvas.removeEventListener('webglcontextrestored', this.handleContextRestored)\n    this.gl.getExtension('WEBGL_lose_context')?.loseContext()\n    if (this.canvas.parentElement) {\n      this.canvas.parentElement.removeChild(this.canvas)\n    }\n  }\n\n  // ── Internal ──────────────────────────────────────────────────\n\n  private handleResize = () => {\n    this.resize()\n  }\n\n  private resize() {\n    const dpr = Math.min(window.devicePixelRatio, 1.5) // Limit for raymarching performance\n    const w = this.container.clientWidth\n    const h = this.container.clientHeight\n    this.canvas.width = Math.floor(w * dpr)\n    this.canvas.height = Math.floor(h * dpr)\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height)\n  }\n\n  private handleMouseMove = (e: MouseEvent) => {\n    const rect = this.canvas.getBoundingClientRect()\n    this.mouseX = (e.clientX - rect.left) / rect.width\n    this.mouseY = 1.0 - (e.clientY - rect.top) / rect.height\n  }\n\n  private handleTouchMove = (e: TouchEvent) => {\n    e.preventDefault()\n    const touch = e.touches[0]\n    const rect = this.canvas.getBoundingClientRect()\n    this.mouseX = (touch.clientX - rect.left) / rect.width\n    this.mouseY = 1.0 - (touch.clientY - rect.top) / rect.height\n  }\n\n  private handleContextLost = (e: Event) => {\n    e.preventDefault()\n    cancelAnimationFrame(this.animationId)\n    showContextLostOverlay(this.container)\n  }\n\n  private handleContextRestored = () => {\n    location.reload()\n  }\n\n  private animate = () => {\n    if (this.disposed) return\n    this.animationId = requestAnimationFrame(this.animate)\n\n    const gl = this.gl\n    const time = (performance.now() - this.startTime) * 0.001\n\n    gl.uniform1f(this.uTime, time)\n    gl.uniform2f(this.uResolution, this.canvas.width, this.canvas.height)\n    gl.uniform2f(this.uMouse, this.mouseX, this.mouseY)\n    gl.uniform1i(this.uScene, this.scene)\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6)\n  }\n}\n"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","toPropertyKey","t","i","r","e","toPrimitive","call","TypeError","String","Number","_defineProperties","length","enumerable","configurable","writable","Object","defineProperty","key","_createClass","compileShader","gl","type","source","shader","createShader","Error","shaderSource","getShaderParameter","COMPILE_STATUS","info","getShaderInfoLog","deleteShader","SCENE_NAMES","RaymarchEngine","container","animationId","disposed","mouseX","mouseY","scene","handleResize","this","resize","handleMouseMove","rect","canvas","getBoundingClientRect","clientX","left","width","clientY","top","height","handleTouchMove","preventDefault","touch","touches","handleContextLost","cancelAnimationFrame","overlay","document","createElement","style","cssText","textContent","addEventListener","location","reload","position","appendChild","showContextLostOverlay","handleContextRestored","animate","requestAnimationFrame","time","performance","now","startTime","uniform1f","uTime","uniform2f","uResolution","uMouse","uniform1i","uScene","drawArrays","TRIANGLES","display","_gl","getContext","alpha","depth","stencil","antialias","preserveDrawingBuffer","program","vertSrc","fragSrc","createProgram","attachShader","VERTEX_SHADER","FRAGMENT_SHADER","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","useProgram","getUniformLocation","quadBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","aPosition","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","window","passive","_proto","setScene","index","Math","max","min","dispose","_this$gl$getExtension","removeEventListener","getExtension","loseContext","parentElement","removeChild","dpr","devicePixelRatio","w","clientWidth","h","clientHeight","floor","viewport","get","concat"],"sourceRoot":""}