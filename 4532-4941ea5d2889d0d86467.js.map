{"version":3,"file":"4532-4941ea5d2889d0d86467.js","mappings":"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","sources":["webpack://jiunbae.github.io/./node_modules/.pnpm/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/const.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/utils.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/errors.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/classes.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/types.js","webpack://jiunbae.github.io/./src/utils/ffmpeg.ts","webpack://jiunbae.github.io/./node_modules/.pnpm/@ffmpeg+util@0.12.2/node_modules/@ffmpeg/util/dist/esm/errors.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@ffmpeg+util@0.12.2/node_modules/@ffmpeg/util/dist/esm/index.js","webpack://jiunbae.github.io/./node_modules/.pnpm/@ffmpeg+util@0.12.2/node_modules/@ffmpeg/util/dist/esm/const.js"],"sourcesContent":["export const MIME_TYPE_JAVASCRIPT = \"text/javascript\";\nexport const MIME_TYPE_WASM = \"application/wasm\";\nexport const CORE_VERSION = \"0.12.9\";\nexport const CORE_URL = `https://unpkg.com/@ffmpeg/core@${CORE_VERSION}/dist/umd/ffmpeg-core.js`;\nexport var FFMessageType;\n(function (FFMessageType) {\n    FFMessageType[\"LOAD\"] = \"LOAD\";\n    FFMessageType[\"EXEC\"] = \"EXEC\";\n    FFMessageType[\"FFPROBE\"] = \"FFPROBE\";\n    FFMessageType[\"WRITE_FILE\"] = \"WRITE_FILE\";\n    FFMessageType[\"READ_FILE\"] = \"READ_FILE\";\n    FFMessageType[\"DELETE_FILE\"] = \"DELETE_FILE\";\n    FFMessageType[\"RENAME\"] = \"RENAME\";\n    FFMessageType[\"CREATE_DIR\"] = \"CREATE_DIR\";\n    FFMessageType[\"LIST_DIR\"] = \"LIST_DIR\";\n    FFMessageType[\"DELETE_DIR\"] = \"DELETE_DIR\";\n    FFMessageType[\"ERROR\"] = \"ERROR\";\n    FFMessageType[\"DOWNLOAD\"] = \"DOWNLOAD\";\n    FFMessageType[\"PROGRESS\"] = \"PROGRESS\";\n    FFMessageType[\"LOG\"] = \"LOG\";\n    FFMessageType[\"MOUNT\"] = \"MOUNT\";\n    FFMessageType[\"UNMOUNT\"] = \"UNMOUNT\";\n})(FFMessageType || (FFMessageType = {}));\n","/**\n * Generate an unique message ID.\n */\nexport const getMessageID = (() => {\n    let messageID = 0;\n    return () => messageID++;\n})();\n","export const ERROR_UNKNOWN_MESSAGE_TYPE = new Error(\"unknown message type\");\nexport const ERROR_NOT_LOADED = new Error(\"ffmpeg is not loaded, call `await ffmpeg.load()` first\");\nexport const ERROR_TERMINATED = new Error(\"called FFmpeg.terminate()\");\nexport const ERROR_IMPORT_FAILURE = new Error(\"failed to import ffmpeg-core.js\");\n","import { FFMessageType } from \"./const.js\";\nimport { getMessageID } from \"./utils.js\";\nimport { ERROR_TERMINATED, ERROR_NOT_LOADED } from \"./errors.js\";\n/**\n * Provides APIs to interact with ffmpeg web worker.\n *\n * @example\n * ```ts\n * const ffmpeg = new FFmpeg();\n * ```\n */\nexport class FFmpeg {\n    #worker = null;\n    /**\n     * #resolves and #rejects tracks Promise resolves and rejects to\n     * be called when we receive message from web worker.\n     */\n    #resolves = {};\n    #rejects = {};\n    #logEventCallbacks = [];\n    #progressEventCallbacks = [];\n    loaded = false;\n    /**\n     * register worker message event handlers.\n     */\n    #registerHandlers = () => {\n        if (this.#worker) {\n            this.#worker.onmessage = ({ data: { id, type, data }, }) => {\n                switch (type) {\n                    case FFMessageType.LOAD:\n                        this.loaded = true;\n                        this.#resolves[id](data);\n                        break;\n                    case FFMessageType.MOUNT:\n                    case FFMessageType.UNMOUNT:\n                    case FFMessageType.EXEC:\n                    case FFMessageType.FFPROBE:\n                    case FFMessageType.WRITE_FILE:\n                    case FFMessageType.READ_FILE:\n                    case FFMessageType.DELETE_FILE:\n                    case FFMessageType.RENAME:\n                    case FFMessageType.CREATE_DIR:\n                    case FFMessageType.LIST_DIR:\n                    case FFMessageType.DELETE_DIR:\n                        this.#resolves[id](data);\n                        break;\n                    case FFMessageType.LOG:\n                        this.#logEventCallbacks.forEach((f) => f(data));\n                        break;\n                    case FFMessageType.PROGRESS:\n                        this.#progressEventCallbacks.forEach((f) => f(data));\n                        break;\n                    case FFMessageType.ERROR:\n                        this.#rejects[id](data);\n                        break;\n                }\n                delete this.#resolves[id];\n                delete this.#rejects[id];\n            };\n        }\n    };\n    /**\n     * Generic function to send messages to web worker.\n     */\n    #send = ({ type, data }, trans = [], signal) => {\n        if (!this.#worker) {\n            return Promise.reject(ERROR_NOT_LOADED);\n        }\n        return new Promise((resolve, reject) => {\n            const id = getMessageID();\n            this.#worker && this.#worker.postMessage({ id, type, data }, trans);\n            this.#resolves[id] = resolve;\n            this.#rejects[id] = reject;\n            signal?.addEventListener(\"abort\", () => {\n                reject(new DOMException(`Message # ${id} was aborted`, \"AbortError\"));\n            }, { once: true });\n        });\n    };\n    on(event, callback) {\n        if (event === \"log\") {\n            this.#logEventCallbacks.push(callback);\n        }\n        else if (event === \"progress\") {\n            this.#progressEventCallbacks.push(callback);\n        }\n    }\n    off(event, callback) {\n        if (event === \"log\") {\n            this.#logEventCallbacks = this.#logEventCallbacks.filter((f) => f !== callback);\n        }\n        else if (event === \"progress\") {\n            this.#progressEventCallbacks = this.#progressEventCallbacks.filter((f) => f !== callback);\n        }\n    }\n    /**\n     * Loads ffmpeg-core inside web worker. It is required to call this method first\n     * as it initializes WebAssembly and other essential variables.\n     *\n     * @category FFmpeg\n     * @returns `true` if ffmpeg core is loaded for the first time.\n     */\n    load = ({ classWorkerURL, ...config } = {}, { signal } = {}) => {\n        if (!this.#worker) {\n            this.#worker = classWorkerURL ?\n                new Worker(new URL(classWorkerURL, import.meta.url), {\n                    type: \"module\",\n                }) :\n                // We need to duplicated the code here to enable webpack\n                // to bundle worekr.js here.\n                new Worker(new URL(\"./worker.js\", import.meta.url), {\n                    type: \"module\",\n                });\n            this.#registerHandlers();\n        }\n        return this.#send({\n            type: FFMessageType.LOAD,\n            data: config,\n        }, undefined, signal);\n    };\n    /**\n     * Execute ffmpeg command.\n     *\n     * @remarks\n     * To avoid common I/O issues, [\"-nostdin\", \"-y\"] are prepended to the args\n     * by default.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", ...);\n     * // ffmpeg -i video.avi video.mp4\n     * await ffmpeg.exec([\"-i\", \"video.avi\", \"video.mp4\"]);\n     * const data = ffmpeg.readFile(\"video.mp4\");\n     * ```\n     *\n     * @returns `0` if no error, `!= 0` if timeout (1) or error.\n     * @category FFmpeg\n     */\n    exec = (\n    /** ffmpeg command line args */\n    args, \n    /**\n     * milliseconds to wait before stopping the command execution.\n     *\n     * @defaultValue -1\n     */\n    timeout = -1, { signal } = {}) => this.#send({\n        type: FFMessageType.EXEC,\n        data: { args, timeout },\n    }, undefined, signal);\n    /**\n     * Execute ffprobe command.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", ...);\n     * // Getting duration of a video in seconds: ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 video.avi -o output.txt\n     * await ffmpeg.ffprobe([\"-v\", \"error\", \"-show_entries\", \"format=duration\", \"-of\", \"default=noprint_wrappers=1:nokey=1\", \"video.avi\", \"-o\", \"output.txt\"]);\n     * const data = ffmpeg.readFile(\"output.txt\");\n     * ```\n     *\n     * @returns `0` if no error, `!= 0` if timeout (1) or error.\n     * @category FFmpeg\n     */\n    ffprobe = (\n    /** ffprobe command line args */\n    args, \n    /**\n     * milliseconds to wait before stopping the command execution.\n     *\n     * @defaultValue -1\n     */\n    timeout = -1, { signal } = {}) => this.#send({\n        type: FFMessageType.FFPROBE,\n        data: { args, timeout },\n    }, undefined, signal);\n    /**\n     * Terminate all ongoing API calls and terminate web worker.\n     * `FFmpeg.load()` must be called again before calling any other APIs.\n     *\n     * @category FFmpeg\n     */\n    terminate = () => {\n        const ids = Object.keys(this.#rejects);\n        // rejects all incomplete Promises.\n        for (const id of ids) {\n            this.#rejects[id](ERROR_TERMINATED);\n            delete this.#rejects[id];\n            delete this.#resolves[id];\n        }\n        if (this.#worker) {\n            this.#worker.terminate();\n            this.#worker = null;\n            this.loaded = false;\n        }\n    };\n    /**\n     * Write data to ffmpeg.wasm.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", await fetchFile(\"../video.avi\"));\n     * await ffmpeg.writeFile(\"text.txt\", \"hello world\");\n     * ```\n     *\n     * @category File System\n     */\n    writeFile = (path, data, { signal } = {}) => {\n        const trans = [];\n        if (data instanceof Uint8Array) {\n            trans.push(data.buffer);\n        }\n        return this.#send({\n            type: FFMessageType.WRITE_FILE,\n            data: { path, data },\n        }, trans, signal);\n    };\n    mount = (fsType, options, mountPoint) => {\n        const trans = [];\n        return this.#send({\n            type: FFMessageType.MOUNT,\n            data: { fsType, options, mountPoint },\n        }, trans);\n    };\n    unmount = (mountPoint) => {\n        const trans = [];\n        return this.#send({\n            type: FFMessageType.UNMOUNT,\n            data: { mountPoint },\n        }, trans);\n    };\n    /**\n     * Read data from ffmpeg.wasm.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * const data = await ffmpeg.readFile(\"video.mp4\");\n     * ```\n     *\n     * @category File System\n     */\n    readFile = (path, \n    /**\n     * File content encoding, supports two encodings:\n     * - utf8: read file as text file, return data in string type.\n     * - binary: read file as binary file, return data in Uint8Array type.\n     *\n     * @defaultValue binary\n     */\n    encoding = \"binary\", { signal } = {}) => this.#send({\n        type: FFMessageType.READ_FILE,\n        data: { path, encoding },\n    }, undefined, signal);\n    /**\n     * Delete a file.\n     *\n     * @category File System\n     */\n    deleteFile = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.DELETE_FILE,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * Rename a file or directory.\n     *\n     * @category File System\n     */\n    rename = (oldPath, newPath, { signal } = {}) => this.#send({\n        type: FFMessageType.RENAME,\n        data: { oldPath, newPath },\n    }, undefined, signal);\n    /**\n     * Create a directory.\n     *\n     * @category File System\n     */\n    createDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.CREATE_DIR,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * List directory contents.\n     *\n     * @category File System\n     */\n    listDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.LIST_DIR,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * Delete an empty directory.\n     *\n     * @category File System\n     */\n    deleteDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.DELETE_DIR,\n        data: { path },\n    }, undefined, signal);\n}\n","export var FFFSType;\n(function (FFFSType) {\n    FFFSType[\"MEMFS\"] = \"MEMFS\";\n    FFFSType[\"NODEFS\"] = \"NODEFS\";\n    FFFSType[\"NODERAWFS\"] = \"NODERAWFS\";\n    FFFSType[\"IDBFS\"] = \"IDBFS\";\n    FFFSType[\"WORKERFS\"] = \"WORKERFS\";\n    FFFSType[\"PROXYFS\"] = \"PROXYFS\";\n})(FFFSType || (FFFSType = {}));\n","import { FFmpeg } from '@ffmpeg/ffmpeg'\nimport { toBlobURL } from '@ffmpeg/util'\n\nlet ffmpeg: FFmpeg | null = null\nlet loadPromise: Promise<FFmpeg> | null = null\nlet currentProgressHandler: (({ progress }: { progress: number }) => void) | null = null\n\nconst BASE_URL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd'\n\nexport async function getFFmpeg(\n  onProgress?: (progress: number) => void\n): Promise<FFmpeg> {\n  if (ffmpeg && ffmpeg.loaded) {\n    // Re-register progress callback on cached instance\n    if (currentProgressHandler) {\n      ffmpeg.off('progress', currentProgressHandler)\n      currentProgressHandler = null\n    }\n    if (onProgress) {\n      currentProgressHandler = ({ progress }) => {\n        onProgress(Math.min(1, Math.max(0, progress)))\n      }\n      ffmpeg.on('progress', currentProgressHandler)\n    }\n    return ffmpeg\n  }\n\n  if (loadPromise) return loadPromise\n\n  loadPromise = (async () => {\n    const instance = new FFmpeg()\n\n    if (onProgress) {\n      currentProgressHandler = ({ progress }) => {\n        onProgress(Math.min(1, Math.max(0, progress)))\n      }\n      instance.on('progress', currentProgressHandler)\n    }\n\n    await instance.load({\n      coreURL: await toBlobURL(`${BASE_URL}/ffmpeg-core.js`, 'text/javascript'),\n      wasmURL: await toBlobURL(`${BASE_URL}/ffmpeg-core.wasm`, 'application/wasm'),\n    })\n\n    ffmpeg = instance\n    return instance\n  })().catch((err) => {\n    loadPromise = null\n    ffmpeg = null\n    currentProgressHandler = null\n    throw err\n  })\n\n  return loadPromise\n}\n\nexport function terminateFFmpeg() {\n  if (ffmpeg) {\n    ffmpeg.terminate()\n    ffmpeg = null\n    loadPromise = null\n    currentProgressHandler = null\n  }\n}\n","export const ERROR_RESPONSE_BODY_READER = new Error(\"failed to get response body reader\");\nexport const ERROR_INCOMPLETED_DOWNLOAD = new Error(\"failed to complete download\");\n","import { ERROR_RESPONSE_BODY_READER, ERROR_INCOMPLETED_DOWNLOAD, } from \"./errors.js\";\nimport { HeaderContentLength } from \"./const.js\";\nconst readFromBlobOrFile = (blob) => new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        const { result } = fileReader;\n        if (result instanceof ArrayBuffer) {\n            resolve(new Uint8Array(result));\n        }\n        else {\n            resolve(new Uint8Array());\n        }\n    };\n    fileReader.onerror = (event) => {\n        reject(Error(`File could not be read! Code=${event?.target?.error?.code || -1}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n});\n/**\n * An util function to fetch data from url string, base64, URL, File or Blob format.\n *\n * Examples:\n * ```ts\n * // URL\n * await fetchFile(\"http://localhost:3000/video.mp4\");\n * // base64\n * await fetchFile(\"data:<type>;base64,wL2dvYWwgbW9yZ...\");\n * // URL\n * await fetchFile(new URL(\"video.mp4\", import.meta.url));\n * // File\n * fileInput.addEventListener('change', (e) => {\n *   await fetchFile(e.target.files[0]);\n * });\n * // Blob\n * const blob = new Blob(...);\n * await fetchFile(blob);\n * ```\n */\nexport const fetchFile = async (file) => {\n    let data;\n    if (typeof file === \"string\") {\n        /* From base64 format */\n        if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(file)) {\n            data = atob(file.split(\",\")[1])\n                .split(\"\")\n                .map((c) => c.charCodeAt(0));\n            /* From remote server/URL */\n        }\n        else {\n            data = await (await fetch(file)).arrayBuffer();\n        }\n    }\n    else if (file instanceof URL) {\n        data = await (await fetch(file)).arrayBuffer();\n    }\n    else if (file instanceof File || file instanceof Blob) {\n        data = await readFromBlobOrFile(file);\n    }\n    else {\n        return new Uint8Array();\n    }\n    return new Uint8Array(data);\n};\n/**\n * importScript dynamically import a script, useful when you\n * want to use different versions of ffmpeg.wasm based on environment.\n *\n * Example:\n *\n * ```ts\n * await importScript(\"http://localhost:3000/ffmpeg.js\");\n * ```\n */\nexport const importScript = async (url) => new Promise((resolve) => {\n    const script = document.createElement(\"script\");\n    const eventHandler = () => {\n        script.removeEventListener(\"load\", eventHandler);\n        resolve();\n    };\n    script.src = url;\n    script.type = \"text/javascript\";\n    script.addEventListener(\"load\", eventHandler);\n    document.getElementsByTagName(\"head\")[0].appendChild(script);\n});\n/**\n * Download content of a URL with progress.\n *\n * Progress only works when Content-Length is provided by the server.\n *\n */\nexport const downloadWithProgress = async (url, cb) => {\n    const resp = await fetch(url);\n    let buf;\n    try {\n        // Set total to -1 to indicate that there is not Content-Type Header.\n        const total = parseInt(resp.headers.get(HeaderContentLength) || \"-1\");\n        const reader = resp.body?.getReader();\n        if (!reader)\n            throw ERROR_RESPONSE_BODY_READER;\n        const chunks = [];\n        let received = 0;\n        for (;;) {\n            const { done, value } = await reader.read();\n            const delta = value ? value.length : 0;\n            if (done) {\n                if (total != -1 && total !== received)\n                    throw ERROR_INCOMPLETED_DOWNLOAD;\n                cb && cb({ url, total, received, delta, done });\n                break;\n            }\n            chunks.push(value);\n            received += delta;\n            cb && cb({ url, total, received, delta, done });\n        }\n        const data = new Uint8Array(received);\n        let position = 0;\n        for (const chunk of chunks) {\n            data.set(chunk, position);\n            position += chunk.length;\n        }\n        buf = data.buffer;\n    }\n    catch (e) {\n        console.log(`failed to send download progress event: `, e);\n        // Fetch arrayBuffer directly when it is not possible to get progress.\n        buf = await resp.arrayBuffer();\n        cb &&\n            cb({\n                url,\n                total: buf.byteLength,\n                received: buf.byteLength,\n                delta: 0,\n                done: true,\n            });\n    }\n    return buf;\n};\n/**\n * toBlobURL fetches data from an URL and return a blob URL.\n *\n * Example:\n *\n * ```ts\n * await toBlobURL(\"http://localhost:3000/ffmpeg.js\", \"text/javascript\");\n * ```\n */\nexport const toBlobURL = async (url, mimeType, progress = false, cb) => {\n    const buf = progress\n        ? await downloadWithProgress(url, cb)\n        : await (await fetch(url)).arrayBuffer();\n    const blob = new Blob([buf], { type: mimeType });\n    return URL.createObjectURL(blob);\n};\n","export const HeaderContentLength = \"Content-Length\";\n"],"names":["FFMessageType","getMessageID","messageID","ERROR_NOT_LOADED","Error","ERROR_TERMINATED","FFmpeg","loaded","this","onmessage","data","id","type","LOAD","MOUNT","UNMOUNT","EXEC","FFPROBE","WRITE_FILE","READ_FILE","DELETE_FILE","RENAME","CREATE_DIR","LIST_DIR","DELETE_DIR","LOG","forEach","f","PROGRESS","ERROR","trans","signal","Promise","resolve","reject","postMessage","addEventListener","DOMException","once","on","event","callback","push","off","filter","load","classWorkerURL","config","Worker","URL","undefined","exec","args","timeout","ffprobe","terminate","ids","Object","keys","writeFile","path","Uint8Array","buffer","mount","fsType","options","mountPoint","unmount","readFile","encoding","deleteFile","rename","oldPath","newPath","createDir","listDir","deleteDir","FFFSType","ffmpeg","loadPromise","currentProgressHandler","BASE_URL","async","getFFmpeg","onProgress","_ref","progress","Math","min","max","instance","_ref2","coreURL","toBlobURL","wasmURL","catch","err","ERROR_RESPONSE_BODY_READER","ERROR_INCOMPLETED_DOWNLOAD","fetchFile","file","test","atob","split","map","c","charCodeAt","fetch","arrayBuffer","File","Blob","blob","fileReader","FileReader","onload","result","ArrayBuffer","onerror","target","error","code","readAsArrayBuffer","url","mimeType","cb","buf","resp","total","parseInt","headers","get","reader","body","getReader","chunks","received","done","value","read","delta","length","position","chunk","set","e","console","log","byteLength","downloadWithProgress","createObjectURL"],"sourceRoot":""}