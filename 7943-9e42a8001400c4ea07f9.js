"use strict";(self.webpackChunkjiunbae_github_io=self.webpackChunkjiunbae_github_io||[]).push([[7943],{546:function(n,e,t){function o(n){return o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},o(n)}function i(n){var e=function(n,e){if("object"!=o(n)||!n)return n;var t=n[Symbol.toPrimitive];if(void 0!==t){var i=t.call(n,e||"default");if("object"!=o(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(n)}(n,"string");return"symbol"==o(e)?e:e+""}function a(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,i(o.key),o)}}function r(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t.d(e,{A:function(){return r}})},7943:function(n,e,t){t.r(e),t.d(e,{RaymarchEngine:function(){return r}});var o=t(546);function i(n,e,t){const o=n.createShader(e);if(!o)throw new Error("Failed to create shader — WebGL context may be lost");if(n.shaderSource(o,t),n.compileShader(o),!n.getShaderParameter(o,n.COMPILE_STATUS)){const e=n.getShaderInfoLog(o);throw n.deleteShader(o),new Error(`Shader compile error: ${e}`)}return o}const a=["Alien Planet","Crystal Cave","Fractal Landscape","Abstract Geometry"];let r=function(){function n(n){this.animationId=0,this.disposed=!1,this.mouseX=.5,this.mouseY=.5,this.scene=0,this.handleResize=()=>{this.resize()},this.handleMouseMove=n=>{const e=this.canvas.getBoundingClientRect();this.mouseX=(n.clientX-e.left)/e.width,this.mouseY=1-(n.clientY-e.top)/e.height},this.handleTouchMove=n=>{n.preventDefault();const e=n.touches[0],t=this.canvas.getBoundingClientRect();this.mouseX=(e.clientX-t.left)/t.width,this.mouseY=1-(e.clientY-t.top)/t.height},this.handleContextLost=n=>{n.preventDefault(),cancelAnimationFrame(this.animationId),function(n){const e=document.createElement("div");e.style.cssText="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);color:#fff;font:14px/1.5 sans-serif;cursor:pointer;z-index:100",e.textContent="WebGL context lost — click to reload",e.addEventListener("click",()=>location.reload()),n.style.position="relative",n.appendChild(e)}(this.container)},this.handleContextRestored=()=>{location.reload()},this.animate=()=>{if(this.disposed)return;this.animationId=requestAnimationFrame(this.animate);const n=this.gl,e=.001*(performance.now()-this.startTime);n.uniform1f(this.uTime,e),n.uniform2f(this.uResolution,this.canvas.width,this.canvas.height),n.uniform2f(this.uMouse,this.mouseX,this.mouseY),n.uniform1i(this.uScene,this.scene),n.drawArrays(n.TRIANGLES,0,6)},this.container=n,this.canvas=document.createElement("canvas"),this.canvas.style.display="block",this.canvas.style.width="100%",this.canvas.style.height="100%",n.appendChild(this.canvas);const e=this.canvas.getContext("webgl",{alpha:!1,depth:!1,stencil:!1,antialias:!1,preserveDrawingBuffer:!1});if(!e)throw new Error("WebGL not supported");this.gl=e,this.canvas.addEventListener("webglcontextlost",this.handleContextLost),this.canvas.addEventListener("webglcontextrestored",this.handleContextRestored),this.program=function(n,e,t){const o=n.createProgram();if(!o)throw new Error("Failed to create program — WebGL context may be lost");if(n.attachShader(o,i(n,n.VERTEX_SHADER,e)),n.attachShader(o,i(n,n.FRAGMENT_SHADER,t)),n.linkProgram(o),!n.getProgramParameter(o,n.LINK_STATUS))throw new Error(`Program link error: ${n.getProgramInfoLog(o)}`);return o}(e,"\n  attribute vec2 aPosition;\n  void main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n  }\n","\n  precision highp float;\n\n  uniform float uTime;\n  uniform vec2 uResolution;\n  uniform vec2 uMouse;\n  uniform int uScene;\n\n  // ── SDF primitives ─────────────────────────────────────────────\n\n  float sdSphere(vec3 p, float r) {\n    return length(p) - r;\n  }\n\n  float sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n  }\n\n  float sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n  }\n\n  float sdPlane(vec3 p, float h) {\n    return p.y - h;\n  }\n\n  float sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n  }\n\n  // ── SDF operations ─────────────────────────────────────────────\n\n  float opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n  }\n\n  float opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n  }\n\n  vec3 opRepeat(vec3 p, vec3 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n  }\n\n  mat2 rot2D(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n  }\n\n  // ── Scene 0: Alien Planet ──────────────────────────────────────\n\n  float sceneAlienPlanet(vec3 p) {\n    // Ground plane with organic displacement\n    float ground = p.y + 1.0;\n    ground += sin(p.x * 0.8) * cos(p.z * 0.8) * 0.3;\n    ground += sin(p.x * 2.0 + uTime * 0.3) * cos(p.z * 1.5) * 0.1;\n\n    // Twisted columns\n    float columns = 1e10;\n    for (int i = 0; i < 5; i++) {\n      float fi = float(i);\n      float angle = fi * 1.2566; // 2PI/5\n      float radius = 3.0;\n      vec3 colPos = p - vec3(cos(angle) * radius, 0.0, sin(angle) * radius);\n\n      // Twist\n      float twist = sin(colPos.y * 0.5 + uTime * 0.2 + fi) * 0.5;\n      colPos.xz *= rot2D(twist);\n\n      // Organic column shape: cylinder with distortion\n      float col = sdCappedCylinder(colPos, 3.0, 0.3 + sin(colPos.y * 1.5 + fi) * 0.1);\n      col += sin(colPos.y * 3.0 + uTime * 0.5) * 0.05;\n      col += sin(p.x * 2.0 + fi) * cos(p.z * 2.0) * 0.04;\n\n      columns = min(columns, col);\n    }\n\n    // Floating organic orbs\n    float orbs = 1e10;\n    for (int i = 0; i < 3; i++) {\n      float fi = float(i);\n      float t = uTime * 0.3 + fi * 2.094;\n      vec3 orbPos = vec3(sin(t) * 2.0, 1.5 + sin(t * 0.7 + fi) * 0.5, cos(t) * 2.0);\n      float orb = sdSphere(p - orbPos, 0.25 + sin(uTime + fi) * 0.05);\n      orbs = min(orbs, orb);\n    }\n\n    float scene = min(ground, columns);\n    scene = min(scene, orbs);\n    return scene;\n  }\n\n  // ── Scene 1: Crystal Cave ──────────────────────────────────────\n\n  float sceneCrystalCave(vec3 p) {\n    // Cavern shell (inverted sphere)\n    float cavern = -(length(p) - 8.0);\n    cavern += sin(p.x * 1.5) * sin(p.y * 1.5) * sin(p.z * 1.5) * 0.4;\n\n    // Repeated crystal formations\n    vec3 rep = opRepeat(p, vec3(3.0, 4.0, 3.0));\n\n    // Rotate crystals\n    float t = uTime * 0.15;\n    rep.xy *= rot2D(t);\n    rep.yz *= rot2D(t * 0.7);\n\n    float crystals = sdBox(rep, vec3(0.15, 0.6, 0.15));\n    crystals = min(crystals, sdBox(rep, vec3(0.6, 0.15, 0.15)));\n    crystals = min(crystals, sdBox(rep, vec3(0.15, 0.15, 0.6)));\n\n    // Stalactites from ceiling\n    vec3 stalPos = p;\n    stalPos.xz = mod(stalPos.xz + 1.5, 3.0) - 1.5;\n    float stalactites = sdCappedCylinder(stalPos - vec3(0.0, 5.0, 0.0), 2.0, 0.1);\n    stalactites -= sin(stalPos.y * 4.0) * 0.03;\n\n    // Stalagmites from floor\n    float stalagmites = sdCappedCylinder(stalPos + vec3(0.0, 5.0, 0.0), 1.5, 0.12);\n    stalagmites -= sin(stalPos.y * 3.0) * 0.04;\n\n    float scene = cavern;\n    scene = min(scene, crystals);\n    scene = min(scene, stalactites);\n    scene = min(scene, stalagmites);\n    return scene;\n  }\n\n  // ── Scene 2: Fractal Landscape ─────────────────────────────────\n\n  float sceneFractalLandscape(vec3 p) {\n    // Multi-octave terrain\n    float terrain = p.y;\n\n    // Mandelbulb-inspired displacement\n    float scale = 1.0;\n    float detail = 0.0;\n    vec3 q = p * 0.3;\n    for (int i = 0; i < 5; i++) {\n      detail += abs(sin(q.x * scale) * cos(q.z * scale)) / scale;\n      scale *= 2.17;\n      q.xz *= rot2D(0.45);\n    }\n    terrain += detail * 1.5 - 2.0;\n\n    // Add some sharp ridges\n    float ridges = abs(sin(p.x * 0.5 + sin(p.z * 0.3)) * cos(p.z * 0.5)) * 1.2;\n    terrain -= ridges;\n\n    // Floating fractal-esque rocks\n    float rocks = 1e10;\n    for (int i = 0; i < 4; i++) {\n      float fi = float(i);\n      float t = uTime * 0.1;\n      vec3 rockPos = vec3(\n        sin(fi * 1.7 + t) * 5.0,\n        3.0 + sin(fi * 2.3 + t * 0.5) * 1.0,\n        cos(fi * 1.3 + t * 0.7) * 5.0\n      );\n      float rock = sdSphere(p - rockPos, 0.3 + sin(fi + uTime * 0.3) * 0.1);\n      // Fractal displacement on rocks\n      vec3 rp = (p - rockPos) * 4.0;\n      rock += (sin(rp.x) * sin(rp.y) * sin(rp.z)) * 0.05;\n      rocks = min(rocks, rock);\n    }\n\n    return min(terrain, rocks);\n  }\n\n  // ── Scene 3: Abstract Geometry ─────────────────────────────────\n\n  float sceneAbstractGeometry(vec3 p) {\n    float t = uTime * 0.3;\n\n    // Central rotating torus\n    vec3 p1 = p;\n    p1.xy *= rot2D(t);\n    float torus1 = sdTorus(p1, vec2(2.0, 0.3));\n\n    // Second torus, orthogonal\n    vec3 p2 = p;\n    p2.yz *= rot2D(t * 0.7);\n    float torus2 = sdTorus(p2, vec2(2.0, 0.3));\n\n    // Third torus\n    vec3 p3 = p;\n    p3.xz *= rot2D(t * 1.1);\n    float torus3 = sdTorus(p3, vec2(2.0, 0.3));\n\n    // Smooth union of toruses\n    float toruses = opSmoothUnion(torus1, torus2, 0.5);\n    toruses = opSmoothUnion(toruses, torus3, 0.5);\n\n    // Central sphere\n    float sphere = sdSphere(p, 1.0 + sin(t) * 0.2);\n\n    // Orbiting smaller spheres\n    float orbitals = 1e10;\n    for (int i = 0; i < 6; i++) {\n      float fi = float(i);\n      float angle = fi * 1.0472 + t; // 2PI/6\n      vec3 oPos = vec3(\n        cos(angle) * 3.0,\n        sin(fi * 0.5 + t * 0.5) * 1.0,\n        sin(angle) * 3.0\n      );\n      float orb = sdSphere(p - oPos, 0.3);\n      orbitals = min(orbitals, orb);\n    }\n\n    // Smooth union everything\n    float scene = opSmoothUnion(toruses, sphere, 0.3);\n    scene = opSmoothUnion(scene, orbitals, 0.4);\n\n    return scene;\n  }\n\n  // ── Main distance function ─────────────────────────────────────\n\n  float map(vec3 p) {\n    if (uScene == 0) return sceneAlienPlanet(p);\n    if (uScene == 1) return sceneCrystalCave(p);\n    if (uScene == 2) return sceneFractalLandscape(p);\n    return sceneAbstractGeometry(p);\n  }\n\n  // ── Normal calculation (central differences) ──────────────────\n\n  vec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n      map(p + e.xyy) - map(p - e.xyy),\n      map(p + e.yxy) - map(p - e.yxy),\n      map(p + e.yyx) - map(p - e.yyx)\n    ));\n  }\n\n  // ── Sphere tracing ────────────────────────────────────────────\n\n  float raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n      vec3 p = ro + rd * t;\n      float d = map(p);\n      if (d < 0.001) break;\n      t += d;\n      if (t > 100.0) break;\n    }\n    return t;\n  }\n\n  // ── Ambient occlusion approximation ────────────────────────────\n\n  float calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n      float h = 0.01 + 0.12 * float(i);\n      float d = map(p + h * n);\n      occ += (h - d) * sca;\n      sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n  }\n\n  // ── Soft shadow ───────────────────────────────────────────────\n\n  float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 32; i++) {\n      float h = map(ro + rd * t);\n      res = min(res, k * h / t);\n      t += clamp(h, 0.02, 0.1);\n      if (h < 0.001 || t > maxt) break;\n    }\n    return clamp(res, 0.0, 1.0);\n  }\n\n  // ── Scene-specific coloring ────────────────────────────────────\n\n  vec3 getSceneColor(vec3 p, vec3 n, vec3 rd, float t) {\n    vec3 lightDir = normalize(vec3(0.8, 0.6, -0.5));\n    float diff = max(dot(n, lightDir), 0.0);\n    float spec = pow(max(dot(reflect(rd, n), lightDir), 0.0), 32.0);\n    float ao = calcAO(p, n);\n    float shadow = softShadow(p + n * 0.01, lightDir, 0.02, 10.0, 8.0);\n\n    vec3 col;\n\n    if (uScene == 0) {\n      // Alien Planet - warm organic tones\n      vec3 albedo = vec3(0.3, 0.5, 0.4);\n      // Height-based color: lower = dark, higher = bright teal\n      albedo = mix(vec3(0.15, 0.1, 0.08), vec3(0.2, 0.7, 0.5), clamp(p.y * 0.3 + 0.5, 0.0, 1.0));\n      // Columns: more saturated\n      if (abs(p.y) < 3.0 && length(p.xz) > 1.5 && length(p.xz) < 4.5) {\n        albedo = mix(albedo, vec3(0.6, 0.2, 0.8), 0.3);\n      }\n      vec3 ambient = vec3(0.08, 0.05, 0.12) * ao;\n      col = ambient + albedo * diff * shadow + vec3(0.6, 0.8, 0.9) * spec * 0.3;\n\n      // Sky gradient for distant fragments\n      vec3 sky = mix(vec3(0.15, 0.05, 0.2), vec3(0.4, 0.2, 0.5), clamp(rd.y * 0.5 + 0.5, 0.0, 1.0));\n      float fog = 1.0 - exp(-t * 0.04);\n      col = mix(col, sky, fog);\n\n    } else if (uScene == 1) {\n      // Crystal Cave - dark with colored light sources\n      vec3 albedo = vec3(0.3, 0.35, 0.5);\n      // Add crystalline iridescence\n      float irid = sin(dot(p, vec3(1.0, 2.0, 3.0)) * 3.0 + uTime * 0.5);\n      albedo += vec3(0.15, 0.1, 0.25) * irid;\n\n      // Point lights in the cave\n      vec3 lightAccum = vec3(0.0);\n      for (int i = 0; i < 3; i++) {\n        float fi = float(i);\n        vec3 lp = vec3(sin(fi * 2.094 + uTime * 0.2) * 3.0, sin(fi + uTime * 0.3), cos(fi * 2.094 + uTime * 0.2) * 3.0);\n        vec3 lCol = vec3(0.0);\n        if (i == 0) lCol = vec3(0.3, 0.5, 1.0);\n        if (i == 1) lCol = vec3(1.0, 0.3, 0.5);\n        if (i == 2) lCol = vec3(0.3, 1.0, 0.5);\n        float dist = length(p - lp);\n        float atten = 1.0 / (1.0 + dist * dist * 0.1);\n        float ld = max(dot(n, normalize(lp - p)), 0.0);\n        lightAccum += lCol * ld * atten;\n      }\n\n      vec3 ambient = vec3(0.02, 0.02, 0.04) * ao;\n      col = ambient + albedo * (diff * shadow * 0.3 + lightAccum) + vec3(0.5) * spec * 0.2;\n\n      // Dark cave fog\n      float fog = 1.0 - exp(-t * 0.08);\n      col = mix(col, vec3(0.01, 0.01, 0.03), fog);\n\n    } else if (uScene == 2) {\n      // Fractal Landscape - earthy terrain tones\n      vec3 albedo = vec3(0.35, 0.25, 0.15);\n      // Height-based: low=green, mid=brown, high=snow\n      float h = p.y;\n      if (h < -0.5) albedo = vec3(0.1, 0.25, 0.1); // grass\n      else if (h < 0.5) albedo = vec3(0.35, 0.25, 0.15); // dirt/rock\n      else if (h < 1.5) albedo = vec3(0.4, 0.38, 0.35); // stone\n      else albedo = vec3(0.85, 0.88, 0.95); // snow\n\n      // Normal-based grass on slopes\n      if (n.y > 0.7 && h < 0.5) {\n        albedo = mix(albedo, vec3(0.15, 0.35, 0.1), (n.y - 0.7) * 3.0);\n      }\n\n      vec3 skyCol = mix(vec3(0.6, 0.7, 0.9), vec3(0.2, 0.3, 0.6), clamp(rd.y, 0.0, 1.0));\n      vec3 ambient = vec3(0.08, 0.1, 0.15) * ao;\n      col = ambient + albedo * diff * shadow + vec3(0.8, 0.85, 1.0) * spec * 0.15;\n\n      float fog = 1.0 - exp(-t * 0.025);\n      col = mix(col, skyCol * 0.5, fog);\n\n    } else {\n      // Abstract Geometry - clean modern look\n      vec3 albedo = vec3(0.9, 0.92, 0.95);\n      // Fresnel for rim light\n      float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 3.0);\n\n      // Color based on normal direction\n      vec3 normColor = n * 0.5 + 0.5;\n      albedo = mix(albedo, normColor * 0.8 + 0.2, 0.3);\n\n      vec3 lightDir2 = normalize(vec3(-0.5, 0.8, 0.3));\n      float diff2 = max(dot(n, lightDir2), 0.0) * 0.3;\n\n      vec3 ambient = vec3(0.12, 0.1, 0.15) * ao;\n      col = ambient + albedo * (diff * shadow + diff2) + vec3(1.0) * spec * 0.5;\n      col += vec3(0.3, 0.5, 1.0) * fresnel * 0.4;\n\n      // Light fog\n      vec3 bgCol = vec3(0.04, 0.04, 0.06);\n      float fog = 1.0 - exp(-t * 0.03);\n      col = mix(col, bgCol, fog);\n    }\n\n    return col;\n  }\n\n  // ── Main ──────────────────────────────────────────────────────\n\n  void main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / uResolution.y;\n\n    // Camera: mouse X controls orbit angle, mouse Y controls height\n    float mouseX = uMouse.x * 2.0 - 1.0; // -1 to 1\n    float mouseY = uMouse.y * 2.0 - 1.0; // -1 to 1\n    float camAngle = mouseX * 3.14159;\n    float camHeight = mouseY * 3.0;\n\n    vec3 ro, lookAt;\n\n    if (uScene == 0) {\n      // Alien planet: orbit around center\n      ro = vec3(cos(camAngle) * 6.0, 2.0 + camHeight, sin(camAngle) * 6.0);\n      lookAt = vec3(0.0, 0.5, 0.0);\n    } else if (uScene == 1) {\n      // Crystal cave: orbit inside\n      ro = vec3(cos(camAngle) * 3.0, camHeight * 0.5, sin(camAngle) * 3.0);\n      lookAt = vec3(0.0, 0.0, 0.0);\n    } else if (uScene == 2) {\n      // Fractal landscape: orbit from above\n      float orbitT = uTime * 0.05 + camAngle * 0.3;\n      ro = vec3(cos(orbitT) * 8.0, 5.0 + camHeight, sin(orbitT) * 8.0);\n      lookAt = vec3(0.0, -0.5, 0.0);\n    } else {\n      // Abstract: orbit around\n      ro = vec3(cos(camAngle) * 5.5, 1.5 + camHeight, sin(camAngle) * 5.5);\n      lookAt = vec3(0.0, 0.0, 0.0);\n    }\n\n    // Camera matrix\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n\n    // Raymarch\n    float t = raymarch(ro, rd);\n\n    vec3 col;\n\n    if (t < 100.0) {\n      vec3 p = ro + rd * t;\n      vec3 n = calcNormal(p);\n      col = getSceneColor(p, n, rd, t);\n    } else {\n      // Background\n      if (uScene == 0) {\n        // Sky gradient\n        col = mix(vec3(0.15, 0.05, 0.2), vec3(0.4, 0.2, 0.5), clamp(rd.y * 0.5 + 0.5, 0.0, 1.0));\n        // Stars\n        vec3 starUV = rd * 200.0;\n        float star = step(0.98, fract(sin(dot(floor(starUV), vec3(12.9898, 78.233, 45.164))) * 43758.5453));\n        col += star * 0.4;\n      } else if (uScene == 1) {\n        col = vec3(0.01, 0.01, 0.03);\n      } else if (uScene == 2) {\n        col = mix(vec3(0.6, 0.7, 0.9), vec3(0.2, 0.3, 0.6), clamp(rd.y, 0.0, 1.0)) * 0.5;\n      } else {\n        col = vec3(0.04, 0.04, 0.06);\n      }\n    }\n\n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n\n    // Vignette\n    vec2 vUv = gl_FragCoord.xy / uResolution;\n    vec2 vig = vUv * (1.0 - vUv);\n    col *= pow(vig.x * vig.y * 16.0, 0.15);\n\n    gl_FragColor = vec4(col, 1.0);\n  }\n"),e.useProgram(this.program),this.uTime=e.getUniformLocation(this.program,"uTime"),this.uResolution=e.getUniformLocation(this.program,"uResolution"),this.uMouse=e.getUniformLocation(this.program,"uMouse"),this.uScene=e.getUniformLocation(this.program,"uScene"),this.quadBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,-1,-1,1,1,1,-1]),e.STATIC_DRAW);const t=e.getAttribLocation(this.program,"aPosition");e.enableVertexAttribArray(t),e.vertexAttribPointer(t,2,e.FLOAT,!1,0,0),this.startTime=performance.now(),this.resize(),window.addEventListener("resize",this.handleResize),this.canvas.addEventListener("mousemove",this.handleMouseMove),this.canvas.addEventListener("touchmove",this.handleTouchMove,{passive:!1}),this.animate()}var e=n.prototype;return e.setScene=function(n){this.scene=Math.max(0,Math.min(n,a.length-1))},e.dispose=function(){var n;this.disposed=!0,cancelAnimationFrame(this.animationId),window.removeEventListener("resize",this.handleResize),this.canvas.removeEventListener("mousemove",this.handleMouseMove),this.canvas.removeEventListener("touchmove",this.handleTouchMove),this.canvas.removeEventListener("webglcontextlost",this.handleContextLost),this.canvas.removeEventListener("webglcontextrestored",this.handleContextRestored),null===(n=this.gl.getExtension("WEBGL_lose_context"))||void 0===n||n.loseContext(),this.canvas.parentElement&&this.canvas.parentElement.removeChild(this.canvas)},e.resize=function(){const n=Math.min(window.devicePixelRatio,1.5),e=this.container.clientWidth,t=this.container.clientHeight;this.canvas.width=Math.floor(e*n),this.canvas.height=Math.floor(t*n),this.gl.viewport(0,0,this.canvas.width,this.canvas.height)},(0,o.A)(n,[{key:"sceneCount",get:function(){return a.length}},{key:"sceneNames",get:function(){return[].concat(a)}},{key:"currentScene",get:function(){return this.scene}}])}()}}]);
//# sourceMappingURL=7943-9e42a8001400c4ea07f9.js.map